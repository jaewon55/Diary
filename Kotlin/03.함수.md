# 함수
함수는 인자를 받아 표현식을 거쳐 반환하는 하는 식이다.
## 선언
+ 일반적인 함수
```kotlin
fun main(args: Array<String>) {

    val result1 = sum(3, 2) // sum함수에 매개변수 3과 2를 넣음
    println(result1) // 5(3 + 2)
}

fun sum(a: Int, b: Int): Int{
	return a + b
} // 일반적인 함수

fun printSum(a: Int, b: Int): Unit{
	println(a + b)
} // 반환값이 없는 함수
```
함수를 선언할때 반환값의 자료형을 일반적으로 표시하지만 간단한 식으로 추론이 가능하면 생략할 수 있다. 반환값이 없는 함수의 반환형은 Unit으로, 생략이 가능하다.   
   
+ 인자의 default값이 있는 함수
```kotlin
fun main(args: Array<String>) {

    val result = minus(b = 8)
    println(result) // 3(8 - 5)
}

fun minus(a: Int = 5, b: Int) = if (a >= b) a - b else b - a// 간략화된 함수
```
매개변수 이름과 함께 함수 호출할 수 있고 함수 선언시 인자에 기본값(default)을 넣으면 매개변수가 없으면 기본값으로 함수를 호출한다.   
   
+ 가변인자를 받는 함수
```kotlin
fun main(args: Array<String>) {
    normalVarargs(1, 2, 3) // 1\n2\n3\n
    normalVarargs(4, 5)	// 4\n5\n
}

fun normalVarargs(vararg counts: Int) {
    for (num in counts) {
        println(num)
    }
}
```
매개변수의 개수가 고정되지 않은 경우 함수는 가변인자를 받을 수 있다. 가변인자는 각 인자를 배열의 형태로 저장한다.   
   
## 함수와 스택 프레임
함수를 선언하고 호출하면 메모리상 Stack에 해당 함수의 프레임이 생성되고 함수 프레임에는 반환블럭(중괄호)안에서 선언된 지역변수, 항(Operand) 스택, 상수 풀, 객체주소 등등이 담겨진다. Stack에 생성된 프레임은 사용이 끝나면 사라진다.
(Operand Stack : 바이트 코드에서 한바이트씩 읽어낸 피연산자(Operand)를 연산하는 공간)   
   
```kotlin
fun main() { // main()함수의 프레임이 스택에 생성
    val num1 = 10
    val num2 = 3
    val result: Int
//  지역변수 num1, num2, result가 프레임안에 쌓인다(push).

    result = max(num1, num2) //max()함수의 프레임이 생성
    // result에 값(10)이 저장되면 max()함수의 프레임이 없어진다.
    println(result)
} // main()함수의 프레임이 사라짐

fun max(a: Int, b: Int) = if (a > b) a else b // 프레임에 지역변수가 생성(push)
```
코드를 실행하면 main()함수의 프레임이 Stack에 생성되고 프레임안에 지역변수(num1, num2, result)가 순서대로 쌓인다.(push)   
   
max() 함수가 호출되면서 max()함수의 프레임이 생성되고 지역변수(a, b)가 생성되고 result에 값이 저장되고 사용이 끝난 max()함수의 프레임은 사라지고 result값을 출력하면서 main()함수도 프레임이 해제된다.

## 함수형 프로그래밍
코틀린은 객체 지향 프로그래밍(OOP)과 함수형 프로그래밍(FP)을 동시에 지원하는 다중 패러다임 언어이다.
+ 함수형 프로그래밍?
	+ 함수를 매개변수, 인자, 반환값으로 사용하는 등 다양한 함수 조합을 사용하는 패러다임으로 프로그램을 모듈화해 디버깅하거나 테스트가 쉽고 코드가 간결해진다.

	+ 순수함수 : 부작용이 없는 함수
		+ 동일한 입력인자에 대해서 항상 같은 결과를 반환해 값이 예측 가능하고 함수 외부의 어떤 상태도 바꾸지 않다.
		+ 특정 상태에 영향을 주지 않으므로 병행 작업시 안전하다.
	+ 일급객체
		+ 일급 객체는 함수의 인자로 전달할 수 있다.
		+ 일급 객체는 함수의 반환값으로 사용할 수 있다.
		+ 일급 객체는 변수에 담을 수 있다.
		+ 코틀린에서 함수를 1급 객체로 다룬다.
	
	+ 정리 -> 함수형 프로그래밍은 순수함수를 조합해 부작용이 없는 루틴을 만들어 내며 람다식을 이용해 함수를 변수처럼 매개변수, 인자, 반환값 등에 활용하는 고챃함수를 구성해 생산성을 높인 프로그래밍 방법이다.

## 고차 함수와 람다식
+ 고차 함수의 형태
```kotlin
fun main(args: Array<String>) {
    val res1 = mul(sum(2, 3), 5) // 매개변수에 함수 사용
    println(res1) // 25
    println(sum2(2, 5)) // 7
}

fun sum(a: Int, b: Int) = a + b
fun mul(a: Int, b: Int) = a * b
fun sum2(a: Int, b: Int): Int {
    return sum(a, b) // 반환값에 함수 사용
}
```
고차함수는 매개변수, 변수, 반환값 등에 함수를 사용하는 형태   
+ 람다식
```kotlin
fun main(args: Array<String>) {
    val multi = { a: Int, b: Int -> a + b } // 변수에 람다식 함수 작성
    println(multi(1, 2)) // 3

    val lambda1: (Int, Int) -> Int = { x: Int, y: Int -> x + y } // 전체표현
    val lambda2: (Int, Int) -> Int = { x, y -> x + y } // 매개변수 자료형 생략
    val lambda3 = { x: Int, y: Int -> x + y } // 선언 자료형 생략
//    val lambda4 = { x, y -> x + y } 에러, 추론이 불가능
}
```
고차함수의 형태를 람다식으로 유연하게 표현이 가능하다.  
+ 람다식의 구성1 : 반환 자료형이 없는 경우
```kotlin
fun main(args: Array<String>) {
    // 반환 자료형이 없는 경우
    val great: () -> Unit = { println("Hello world") }
//  val great = {println("Hello world")}로 생략 가능  
    great() // Hello world
    val new = out // 변수처럼 할당이 가능
    new() // Hello world
}
```
+ 람다식의 구성2 : 람다식 안에 람다식이 있는 경우
```kotlin
fun main(args: Array<String>) {
    // 람다식 안에 람다식이 있는 경우
    val nestedLambda: () -> () -> Unit = { { println("nested") } }
    nestedLambda() // 아무것도 나오지 않는다
    nestedLambda()() // nested
}
```
+ 람다식의 구성3 : 표현식이 2줄 이상일 때
```kotlin
fun main(args: Array<String>) {
    // 표현식이 2줄 이상일 때	
    val multi = { x: Int, y: Int ->
        println("Hello")
        x * y // 마지막 표현식이 반환값이 된다.
    }
    println(multi(2, 3)) // Hello\n6
}
```
+ 람다식 구성4 : 매개변수에 람다식 함수를 이용한 고차 함수
```kotlin
fun main(args: Array<String>) {
    // 매개변수에 람다식 함수를 이용한 고차 함수
    val result = highOrder({ x, y -> x + y }, 2, 3)
    println(result) // 5
}

fun highOrder(sum: (Int, Int) -> Int, a: Int, b: Int) = sum(a, b)
```
+ 람다식 구성5 : 값에 의한 호출로 람다식 사용하기
```kotlin
fun main(args: Array<String>) {
    val result = callByValue(lambda())
    println(result)
//    lambda function
//    callByValue
//    true
}

fun callByValue(b: Boolean): Boolean {
    println("callByValue")
    return b
}

val lambda: () -> Boolean = {
    println("lambda function")
    true
}
```
+ 람다식 구성6 : 람다식 이름을 사용한 호출
```kotlin
fun main(args: Array<String>) {
    val result = callByName(otherLambda)
    println(result)
//    callByName
//    otherLambda function
//    true
}

fun callByName(b: () -> Boolean): Boolean {
    println("callByName")
    return b()
}

val otherLambda: () -> Boolean = {
    println("otherLambda function")
    true
}
```
+ 람다식 구성7 : 다른 함수의 참조에 의한 호출
```kotlin
fun main(args: Array<String>) {
//    funcParam(1, 2, sum)  오류 sum은 람다식이 아니기 때문에 자료형이 맞지 않다.
    val res1 = funcParam(1, 2, ::sum) // ::sum함수를 참조
    println(res1) // 3
}

fun sum(x: Int, y: Int) = x + y

fun funcParam(a: Int, b: Int, c: (Int, Int) -> Int) = c(a, b)
```

+ 람다식 구성8 : 람다식 함수의 매개변수
```kotlin
fun main(args: Array<String>) {
    // 매개변수 없는 람다식 함수
    noParam { "Hello world" } // 소괄호 생략 가능

    // 매개변수가 한 개인 경우
//  oneParam { a -> "Hello world $a" }
    oneParam { "Hello world $it" } // 소괄호와 매개변수를 it으로 대체

    // 매개변수가 두 개 이상인 경우
    moreParam { a, b -> a + b } // 매개변수 생략 불가
    moreParam { _, b -> b } // 첫 번째 매개변수를 사용하지 않고 생략

    // 일반 매개변수와 람다식 매개변수를 같이 사용
    withArgs("Arg1", "Arg2") { a, b -> "Hello world $a $b" }
    // 마지막 인자가 람다식인 경우 소괄호 바깥으로 분리 가능
}

fun noParam(out: () -> Unit) = println(out())
fun oneParam(out: (String) -> String) = println(out("OneParam"))
fun moreParam(out: (String, String) -> String) {
    println(out("OneParam", "TowParam"))
}

fun withArgs(a: String, b: String, out: (String, String) -> String) {
    println(out(a, b))
}
```