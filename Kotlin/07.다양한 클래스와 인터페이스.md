# 다양한 클래스와 인터페이스
## 추상 클래스와 인터페이스
+ 추상 클래스(abstract class)
	+ 구현 클래스에서 가져야할 명세를 정의한 클래스(하위 클래스가 가져야할 뼈대)
	+ 추상 클래스는 객체 생성이 안된다.
	+ '구체적이지 않은 것'을 나타내기 때문에 하위 클래스에서 구체적으로 구현해야 한다.
	+ open 키워드를 사용하지 않고도 파생 클래스 작성 가능
	+ object를 사용해 단일 인슽턴스로 객체 생성이 가능
+ 추상 클래스 예제
```kotlin
fun main(args: Array<String>) {
    val car = Car("Matiz", "red", 1000.0, 100.0)
    car.year = "2014"
    car.displaySpec() // name : Matiz, color : red, wieght: 1000.0, year : 2014, maxSpeed : 100.0
    car.start() // Car Started
    car.stop() // Car Stopped
}
// 추상 클래스 선언
abstract class Vehicle(val name: String, val color: String, val weight: Double) {
    // 추상 프로퍼티 - 하위 클래스에서 오버라이딩 해야한다.
    abstract val maxSpeed: Double

    // 비추상 프로퍼티
    var year: String = "2008"

    // 추상 메서드 - 하위 클래스에서 오버라이딩 해야한다.
    abstract fun start()
    abstract fun stop()

    // 비추상 메서드 - 하위 클래스가 기본적으로 같은 내용을 가지게 된다.
    fun displaySpec() {
        println("name : $name, color : $color, wieght: $weight, year : $year, maxSpeed : $maxSpeed")
    }
}
// 하위 파생 클래스
class Car(
    name: String,
    color: String,
    weight: Double,
    override val maxSpeed: Double // 추상 클래스와 메서드는 반드시 오버라딩 해야한다.
) : Vehicle(name, color, weight) {
    override fun start() { // 추상 메서드
        println("Car Started")
    }

    override fun stop() { // 추상 메서드
        println("Car Stopped")
    }

    fun autoPilotOn() {
        println("$name Auto Pilot ON")
    }
}
// object를 사용한 단일 인스턴스 객체 생성
val bike = object : Vehicle("moter", "blue", 500.0) {
    override val maxSpeed: Double = 500.0
    override fun start() {
        println("Bike Started")
    }

    override fun stop() {
        println("Bike Stopped")
    }
}
```