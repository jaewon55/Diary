# 다양한 클래스와 인터페이스
## 추상 클래스와 인터페이스
+ 추상 클래스(abstract class)
	+ 구현 클래스에서 가져야할 명세를 정의한 클래스(하위 클래스가 가져야할 뼈대)
	+ 추상 클래스는 객체 생성이 안된다.
	+ '구체적이지 않은 것'을 나타내기 때문에 하위 클래스에서 구체적으로 구현해야 한다.
	+ open 키워드를 사용하지 않고도 파생 클래스 작성 가능
	+ object를 사용해 단일 인스턴스로 객체 생성이 가능
+ 추상 클래스 예제
```kotlin
fun main(args: Array<String>) {
    val car = Car("Matiz", "red", 1000.0, 100.0)
    car.year = "2014"
    car.displaySpec() // name : Matiz, color : red, wieght: 1000.0, year : 2014, maxSpeed : 100.0
    car.start() // Car Started
    car.stop() // Car Stopped
}
// 추상 클래스 선언
abstract class Vehicle(val name: String, val color: String, val weight: Double) {
    // 추상 프로퍼티 - 하위 클래스에서 오버라이딩 해야한다.
    abstract val maxSpeed: Double

    // 비추상 프로퍼티
    var year: String = "2008"

    // 추상 메서드 - 하위 클래스에서 오버라이딩 해야한다.
    abstract fun start()
    abstract fun stop()

    // 비추상 메서드 - 하위 클래스가 기본적으로 같은 내용을 가지게 된다.
    fun displaySpec() {
        println("name : $name, color : $color, wieght: $weight, year : $year, maxSpeed : $maxSpeed")
    }
}
// 하위 파생 클래스
class Car(
    name: String,
    color: String,
    weight: Double,
    override val maxSpeed: Double // 추상 클래스와 메서드는 반드시 오버라딩 해야한다.
) : Vehicle(name, color, weight) {
    override fun start() { // 추상 메서드
        println("Car Started")
    }

    override fun stop() { // 추상 메서드
        println("Car Stopped")
    }

    fun autoPilotOn() {
        println("$name Auto Pilot ON")
    }
}
// object를 사용한 단일 인스턴스 객체 생성
val bike = object : Vehicle("moter", "blue", 500.0) {
    override val maxSpeed: Double = 500.0
    override fun start() {
        println("Bike Started")
    }

    override fun stop() {
        println("Bike Stopped")
    }
}
```
   
+ 인터페이스
	+ 인터페이스에 선언된 프로퍼티와 메서드는 기본적으로 추상 프로퍼티와 메서드 이다. 따라서 하위 클래스에서 구현(override)해야 된다.
	+ 코틀린에서는 인터페이스에 선언된 메서드에 기본적인 구현 내용이 포함될 수 있다.
	+ 인터페이스에서는 프로퍼티에 값을 저장할 수 없지만 val로 선언된 프로퍼티는 게터를 통해 필요한 내용을 구현할 수 있다.
	+ 추상 클래스와 차이점 : 클래스가 아니기 때문에 다양한 하위 클래스가 다양한 인터페이스를 상속받을 수 있다.(다중 상속) 또한 하위 클래스와 강한 연관을 가지지 않는다.
```kotlin
fun main(args: Array<String>) {
    val cat = Cat("coco", "Small")
    val dog = Dog("dodo", "Big")
    val master = Master()
    master.playWithPet(cat) // Enjoy with my cat
    master.playWithPet(dog) // Enjoy with my dog
    println(dog.magTags) // I'm your lovely Big pet!
}

open class Animal(val name: String)
interface Pet {
    var category: String // 추상 프로퍼티
    var species: String
    val magTags: String // val로 선언된 프로퍼티에 게터로 내용 구현
        get() = "I'm your lovely $category pet!"

    fun feeding() // 추상 메서드
    fun patting() {
        println("keep patting!")
    }
}

class Cat(name: String, override var category: String) : Animal(name), Pet {
    override var species: String = "cat"
    override fun feeding() {
        println("Feed the dog a bone")
    }
}

class Dog(name: String, override var category: String) : Animal(name), Pet {
    override var species: String = "dog"
    override fun feeding() {
        println("Feed the dog a bone")
    }
}

class Master {
    // 매개변수를 인터페이스로 지정함
    fun playWithPet(pet: Pet) {
        println("Enjoy with my ${pet.species}")
    }
}
```
클래스 ```Animal``` 과 인터페이스 ```Pet```이 선언되었고 하위 클래스 ```Dog```과 ```Cat```은 각각 ```Animal```과 ```Pet```을 상속 받는다. 클래스는 다중상속이 불가능 하지만 ```Pet```이 인페이스이기 때문에 클래스```Animal```과 같이 상속 받을 수 있다.
```Master```클래스의 ```playWithPet``` 메서드는 ```Pet```을 인자로 받아 ```species```프로퍼티를 사용하고 있다.