# 제네릭과 배열
## 제네릭
+ 제네릭?
	+ 자료형의 객체를 다루는 메서드나 클래스에서 컴파일 시간에 적당한 자료형을 선택하도록 하기 위해 사용
	+ 앵글 브래킷```<>```사이에 형식 매개변수를 사용해 선언한다.
+ 간단한 제네릭 예제
```kotlin
fun main(args: Array<String>) {
    val box1: Box<Int> = Box<Int>(1)
    val box2: Box<String> = Box<String>("Hello")
    val box3 = Box(3.0) // 타입이 추론 가능한 경우 생략
}

class Box<T>(var t: T) {
    var name = t
}
```
   
   
+ 형식 매개변수
	+ 제네릭 사용시 ```<>```사이에 사용, 자료형을 대표하는 용어로 T를 일반적으로 사용한다.
	+ 형식 매개변수는 기본적으로 null이 허용된다. null을 허용하지 않기 위해서는 ```<T: Any>```로 특정 자료형으로 제한한다.
	+ 일종의 규칙처럼 T이외에 E, K, U, V 등이 사용된다.
+ 자료형 제한
```kotlin
fun main(args: Array<String>) {
    val calc1 = Calc<Int>()
    val calc2 = Calc<Double>()
    val calc3 = Calc<Long>()
//    val calc4 = Calc<String>() 제한된 자료형으로 오류발생
}

class Calc<T : Number> {// 클래스의 형식 매개변수 제한
    fun plus(arg1: T, arg2: T): Double {
        return arg1.toDouble() + arg2.toDouble()
    }
}
```
+ 형식 매개변수 이름과 의미
```
// 강제성은 없으나 규칙처럼 사용됨
이름		의미
E		요소(element)
K		키(key)
N		숫자(number)
T		형식(type)
V		값(value)
S, U, V..	두 번째, 세 번째, 네 번째 형식
```
   
   
+ 제네릭 클래스
	+ 형식 매개변수를 한개 이상 받는 클래스로 객체를 생성하는 시점에서 클래스의 자료형을 정한다.
	+ 프로퍼티에 지정하는 경우 주 생성자나 부 생성자에 형식 매개변수를 지정해 사용해야함
+ 주 생성자의 형식 매개변수
```kotlin
fun main(args: Array<String>) {
    var a = MyClass<Int>(12)
    println(a.myProp) // 12
    val b = MyClass<Int?>(null) // 형식 매개변수는 null이 허용
    println(b.myProp) // null
}

class MyClass<T>(val myProp: T)
```
   
   
+ 제네릭 함수 혹은 메서드
    + 함수 혹은 메서드 앞쪽에 ```<T>```와 같이 지정
    + 함수가 호출될 때 컴파일러가 자료형 추론
    + 반환 자료형과 매개변수 자료형에 사용할 수 있다.
+ 제네릭 함수 예제
```kotlin
fun main(args: Array<String>) {
    val arr1: Array<String> = arrayOf("Apple", "Banana", "Cherry", "Durian")
    val arr2: Array<Int> = arrayOf(1, 2, 3, 4)
    println(find(arr1, "Cherry")) // 2
    println(find(arr2, 2)) // 1
}

fun <T> find(a: Array<T>, Target: T): Int {
    for (i in a.indices) {
        if (a[i] == Target) return i
    }
    return -1
}
```
   
   
+ 가변성(variance)
    + 형식 매개변수가 클래스 계층에 어떤 영향을 미치는지 정의
    + 상,하위 자료형 : 하위자료형은 상위자료형이 수용, 반대는 불가능
    ex) ```Int```는 ```Number```의 하위 자료형(subtype)이다
```kotlin
val intager : Int = 1
val number: Number = intager // 하위 자료형 Int를 Number가 수용
```
 + 가변성의 3가지 유형
    1. 공변성 : ```T```가 ```U```의 하위 자료형이면 ```C<T>```는 ```C<U>```의 하위 자료형이다. 생산자 입장의 out성질
        + 형식 매개변수 사이의 하위 자료형 관계가 성립한다.
        + 하위 자료형 관계가 그대로 객체 자료형 사이의 관계로 이어지는 경우
        + out 키워드로 정의한다.
        + 읽기 전용, get으로 값을 읽거나 반환만 가능
    2. 반공변성 : ```T```가 ```U```의 하위 자료형이면 ```C<U>```는 ```C<T>```의 하위 자료형이다. 소비자 입장의 in성질
        + 자료형의 상하 관계가 반대로 적용된다.
        + 하위 클래스의 자료형을 상위 클래스의 자료형이 허용한다.
        + in 키워드로 정의한다.
        + 쓰기 전용, setter만 가능
    3. 무변성 : ```C<U>```와 ```C<T>```는 아무 관계가 없다. 생산자 + 소비자
        + 자료형 사이의 하위 자료형 관계가 성립하지 않는다.
        + 형식 매개변수에 in/out을 지정하지 않으면 기본적으로 무변성이다.
```kotlin
// 공변성
class Box<out T>(val size: Int)

fun main(args: Array<String>) {
    val anys: Box<Any> = Box<Int>(10) // 관계 성립
    val notings: Box<Nothing> = Box<Int>(20) // 자료형 불일치 오류
}
```
   
```kotlin
// 반공변성
class Box<in T>(val size: Int)

fun main(args: Array<String>) {
    val anys: Box<Any> = Box<Int>(10) // 자료형 불일치 오류
    val notings: Box<Nothing> = Box<Int>(20) // 관계 성립
}
```
   
```kotlin
// 무변성
class Box<T>(val size: Int)

fun main(args: Array<String>) {
    val anys: Box<Any> = Box<Int>(10) // 자료형 불일치 오류
    val notings: Box<Nothing> = Box<Int>(20) // 자료형 불일치 오류
}
```
   
   
+ 가변성 지정 방식
    + 가변성은 out/in 키워드로 지정할 수 있다. 기변성을 지정하는 지점에 따라 선언 지점, 사용 지점으로 나뉜다.
        + 선언 지점 변성 : 클래스 선언 지점에 가변성을 지정하는 방식으로 클래스 전체에 가변성을 전체적으로 지정한다.
        + 사용 지점 변성 : 매개변수, 메서드등 사용 위치에서 가변성을 지정하는 방식
```kotlin
// 사용 지점 변성
class Box<T>(var size: T)

fun <T> printObj(box: Box<out Int>) { // 사용지점에 가변성 지정
    val obj: Int = box.size
    box.size = 10 // 오류 out은 읽기 전용으로 set이 불가능
}
```
   
   
+ 스타 프로젝션
    + 어떤 자료형이라도 들어올 수 있으나 구체적으로 자료형이 결정되고 난 후에는 그 자료형과 하위 자료형의 요소만 담을 수 있도록 제한
    + in으로 정의되어 있는 형식 매개변수를 *로 받으면 Nothing인 것으로 간주
    + out으로 정의되어 있는 형식 매개변수를 *로 받으면 Any?인 것으로 간주
+ 스타 프로젝션 예제
```kotlin
class InOutTest<in T,  out U>(t: T, u: U) {
    val propT = t // t는 in으로 쓰기 전용, get불가
    val propU = u

    fun func1(t: T) {}
    fun func2(u: U){} // u는 out으로 읽기 전용, set불가
}

fun starTestFunc(v: InOutTest<*, *>) {
    v.func1(1) // Nouthing으로 인자를 처리한다.
    println(v.propU)
}
```